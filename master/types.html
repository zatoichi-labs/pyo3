<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GIL, mutability and object types - PyO3 user guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="module.html"><strong aria-hidden="true">1.</strong> Python Modules</a></li><li class="chapter-item expanded "><a href="function.html"><strong aria-hidden="true">2.</strong> Python Functions</a></li><li class="chapter-item expanded "><a href="class.html"><strong aria-hidden="true">3.</strong> Python Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/protocols.html"><strong aria-hidden="true">3.1.</strong> Class customizations</a></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> Type Conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversions/tables.html"><strong aria-hidden="true">4.1.</strong> Mapping of Rust types to Python types</a></li><li class="chapter-item expanded "><a href="conversions/traits.html"><strong aria-hidden="true">4.2.</strong> Conversion traits</a></li></ol></li><li class="chapter-item expanded "><a href="exception.html"><strong aria-hidden="true">5.</strong> Python Exceptions</a></li><li class="chapter-item expanded "><a href="python_from_rust.html"><strong aria-hidden="true">6.</strong> Calling Python from Rust</a></li><li class="chapter-item expanded "><a href="types.html" class="active"><strong aria-hidden="true">7.</strong> GIL, mutability and object types</a></li><li class="chapter-item expanded "><a href="parallelism.html"><strong aria-hidden="true">8.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">9.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">10.</strong> Features Reference</a></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">11.</strong> Advanced Topics</a></li><li class="chapter-item expanded "><a href="building_and_distribution.html"><strong aria-hidden="true">12.</strong> Building and Distribution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building_and_distribution/pypy.html"><strong aria-hidden="true">12.1.</strong> PyPy support</a></li></ol></li><li class="chapter-item expanded "><a href="ecosystem.html"><strong aria-hidden="true">13.</strong> Useful Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecosystem/logging.html"><strong aria-hidden="true">13.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="ecosystem/async-await.html"><strong aria-hidden="true">13.2.</strong> Async / Await</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">14.</strong> FAQ &amp; Troubleshooting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="migration.html">Appendix A: Migration Guide</a></li><li class="chapter-item expanded affix "><a href="rust_cpython.html">Appendix B: PyO3 and rust-cpython</a></li><li class="chapter-item expanded affix "><a href="trait_bounds.html">Appendix C: Trait bounds</a></li><li class="chapter-item expanded affix "><a href="changelog.html">CHANGELOG</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#gil-lifetimes-mutability-and-python-object-types" id="gil-lifetimes-mutability-and-python-object-types">GIL lifetimes, mutability and Python object types</a></h1>
<p>On first glance, PyO3 provides a huge number of different types that can be used
to wrap or refer to Python objects.  This page delves into the details and gives
an overview of their intended meaning, with examples when each type is best
used.</p>
<h2><a class="header" href="#mutability-and-rust-types" id="mutability-and-rust-types">Mutability and Rust types</a></h2>
<p>Since Python has no concept of ownership, and works solely with boxed objects,
any Python object can be referenced any number of times, and mutation is allowed
from any reference.</p>
<p>The situation is helped a little by the Global Interpreter Lock (GIL), which
ensures that only one thread can use the Python interpreter and its API at the
same time, while non-Python operations (system calls and extension code) can
unlock the GIL.  (See <a href="parallelism.html">the section on parallelism</a> for how to do
that in PyO3.)</p>
<p>In PyO3, holding the GIL is modeled by acquiring a token of the type
<code>Python&lt;'py&gt;</code>, which serves three purposes:</p>
<ul>
<li>It provides some global API for the Python interpreter, such as
<a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.eval"><code>eval</code></a>.</li>
<li>It can be passed to functions that require a proof of holding the GIL,
such as <a href="https://docs.rs/pyo3/latest/pyo3/struct.Py.html#method.clone_ref"><code>Py::clone_ref</code></a>.</li>
<li>Its lifetime can be used to create Rust references that implicitly guarantee
holding the GIL, such as <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>&amp;'py PyAny</code></a>.</li>
</ul>
<p>The latter two points are the reason why some APIs in PyO3 require the <code>py: Python</code> argument, while others don't.</p>
<p>The PyO3 API for Python objects is written such that instead of requiring a
mutable Rust reference for mutating operations such as
<a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyList.html#method.append"><code>PyList::append</code></a>, a shared reference (which, in turn, can only
be created through <code>Python&lt;'_&gt;</code> with a GIL lifetime) is sufficient.</p>
<p>However, Rust structs wrapped as Python objects (called <code>pyclass</code> types) usually
<em>do</em> need <code>&amp;mut</code> access.  Due to the GIL, PyO3 <em>can</em> guarantee thread-safe acces
to them, but it cannot statically guarantee uniqueness of <code>&amp;mut</code> references once
an object's ownership has been passed to the Python interpreter, ensuring
references is done at runtime using <code>PyCell</code>, a scheme very similar to
<code>std::cell::RefCell</code>.</p>
<h2><a class="header" href="#object-types" id="object-types">Object types</a></h2>
<h3><a class="header" href="#a-hrefhttpsdocsrspyo3latestpyo3typesstructpyanyhtmlpyanya" id="a-hrefhttpsdocsrspyo3latestpyo3typesstructpyanyhtmlpyanya"><a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>PyAny</code></a></a></h3>
<p><strong>Represents:</strong> a Python object of unspecified type, restricted to a GIL
lifetime.  Currently, <code>PyAny</code> can only ever occur as a reference, <code>&amp;PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to refer to some Python object and will have the
GIL for the whole duration you need to access that object. For example,
intermediate values and arguments to <code>pyfunction</code>s or <code>pymethod</code>s implemented
in Rust where any type is allowed.</p>
<p>Many general methods for interacting with Python objects are on the <code>PyAny</code> struct,
such as <code>getattr</code>, <code>setattr</code>, and <code>.call</code>.</p>
<p><strong>Conversions:</strong></p>
<p>For a <code>&amp;PyAny</code> object reference <code>any</code> where the underlying object is a Python-native type such as
a list:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::{Py, Python, PyAny, PyResult, types::PyList};
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let obj: &amp;PyAny = PyList::empty(py);

// To &amp;PyList with PyAny::downcast
let _: &amp;PyList = obj.downcast()?;

// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = obj.into();

// To Py&lt;PyList&gt; with PyAny::extract
let _: Py&lt;PyList&gt; = obj.extract()?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>For a <code>&amp;PyAny</code> object reference <code>any</code> where the underlying object is a <code>#[pyclass]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::{Py, Python, PyAny, PyResult, types::PyList};
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let obj: &amp;PyAny = Py::new(py, MyClass { })?.into_ref(py);

// To &amp;PyCell&lt;MyClass&gt; with PyAny::downcast
let _: &amp;PyCell&lt;MyClass&gt; = obj.downcast()?;

// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = obj.into();

// To Py&lt;MyClass&gt; with PyAny::extract
let _: Py&lt;MyClass&gt; = obj.extract()?;

// To MyClass with PyAny::extract, if MyClass: Clone
let _: MyClass = obj.extract()?;

// To PyRef&lt;MyClass&gt; or PyRefMut&lt;MyClass&gt; with PyAny::extract
let _: PyRef&lt;MyClass&gt; = obj.extract()?;
let _: PyRefMut&lt;MyClass&gt; = obj.extract()?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pytuple-pydict-and-many-more" id="pytuple-pydict-and-many-more"><code>PyTuple</code>, <code>PyDict</code>, and many more</a></h3>
<p><strong>Represents:</strong> a native Python object of known type, restricted to a GIL
lifetime just like <code>PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to operate with native Python types while holding
the GIL.  Like <code>PyAny</code>, this is the most convenient form to use for function
arguments and intermediate values.</p>
<p>These types all implement <code>Deref&lt;Target = PyAny&gt;</code>, so they all expose the same
methods which can be found on <code>PyAny</code>.</p>
<p>To see all Python types exposed by <code>PyO3</code> you should consult the
<a href="https://docs.rs/pyo3/latest/pyo3/types/index.html"><code>pyo3::types</code></a> module.</p>
<p><strong>Conversions:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let list = PyList::empty(py);

// Use methods from PyAny on all Python types with Deref implementation
let _ = list.repr()?;

// To &amp;PyAny automatically with Deref implementation
let _: &amp;PyAny = list;

// To &amp;PyAny explicitly with .as_ref()
let _: &amp;PyAny = list.as_ref();

// To Py&lt;T&gt; with .into() or Py::from()
let _: Py&lt;PyList&gt; = list.into();

// To PyObject with .into() or .to_object(py)
let _: PyObject = list.into();
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pyt-and-pyobject" id="pyt-and-pyobject"><code>Py&lt;T&gt;</code> and <code>PyObject</code></a></h3>
<p><strong>Represents:</strong> a GIL-independent reference to a Python object. This can be a Python native type
(like <code>PyTuple</code>), or a <code>pyclass</code> type implemented in Rust. The most commonly-used variant,
<code>Py&lt;PyAny&gt;</code>, is also known as <code>PyObject</code>.</p>
<p><strong>Used:</strong> Whenever you want to carry around references to a Python object without caring about a
GIL lifetime.  For example, storing Python object references in a Rust struct that outlives the
Python-Rust FFI boundary, or returning objects from functions implemented in Rust back to Python.</p>
<p>Can be cloned using Python reference counts with <code>.clone()</code>.</p>
<p><strong>Conversions:</strong></p>
<p>For a <code>Py&lt;PyList&gt;</code>, the conversions are as below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span>let list: Py&lt;PyList&gt; = PyList::empty(py).into();

// To &amp;PyList with Py::as_ref() (borrows from the Py)
let _: &amp;PyList = list.as_ref(py);

<span class="boring">let list_clone = list.clone(); // Because `.into_ref()` will consume `list`.
</span>// To &amp;PyList with Py::into_ref() (moves the pointer into PyO3's object storage)
let _: &amp;PyList = list.into_ref(py);

<span class="boring">let list = list_clone;
</span>// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = list.into();
<span class="boring">}
</span></code></pre></pre>
<p>For a <code>#[pyclass] struct MyClass</code>, the conversions for <code>Py&lt;MyClass&gt;</code> are below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let my_class: Py&lt;MyClass&gt; = Py::new(py, MyClass { })?;

// To &amp;PyCell&lt;MyClass&gt; with Py::as_ref() (borrows from the Py)
let _: &amp;PyCell&lt;MyClass&gt; = my_class.as_ref(py);

<span class="boring">let my_class_clone = my_class.clone(); // Because `.into_ref()` will consume `my_class`.
</span>// To &amp;PyCell&lt;MyClass&gt; with Py::into_ref() (moves the pointer into PyO3's object storage)
let _: &amp;PyCell&lt;MyClass&gt; = my_class.into_ref(py);

<span class="boring">let my_class = my_class_clone.clone();
</span>// To Py&lt;PyAny&gt; (aka PyObject) with .into_py(py)
let _: Py&lt;PyAny&gt; = my_class.into_py(py);

<span class="boring">let my_class = my_class_clone;
</span>// To PyRef&lt;MyClass&gt; with Py::borrow or Py::try_borrow
let _: PyRef&lt;MyClass&gt; = my_class.try_borrow(py)?;

// To PyRefMut&lt;MyClass&gt; with Py::borrow_mut or Py::try_borrow_mut
let _: PyRefMut&lt;MyClass&gt; = my_class.try_borrow_mut(py)?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pycellsometype" id="pycellsometype"><code>PyCell&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> a reference to a Rust object (instance of <code>PyClass</code>) which is
wrapped in a Python object.  The cell part is an analog to stdlib's
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> to allow access to <code>&amp;mut</code> references.</p>
<p><strong>Used:</strong> for accessing pure-Rust API of the instance (members and functions
taking <code>&amp;SomeType</code> or <code>&amp;mut SomeType</code>) while maintaining the aliasing rules of
Rust references.</p>
<p>Like pyo3's Python native types, <code>PyCell&lt;T&gt;</code> implements <code>Deref&lt;Target = PyAny&gt;</code>,
so it also exposes all of the methods on <code>PyAny</code>.</p>
<p><strong>Conversions:</strong></p>
<p><code>PyCell&lt;T&gt;</code> can be used to access <code>&amp;T</code> and <code>&amp;mut T</code> via <code>PyRef&lt;T&gt;</code> and <code>PyRefMut&lt;T&gt;</code> respectively.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass { })?;

// To PyRef&lt;T&gt; with .borrow() or .try_borrow()
let py_ref: PyRef&lt;MyClass&gt; = cell.try_borrow()?;
let _: &amp;MyClass = &amp;*py_ref;
<span class="boring">drop(py_ref);
</span>
// To PyRefMut&lt;T&gt; with .borrow_mut() or .try_borrow_mut()
let mut py_ref_mut: PyRefMut&lt;MyClass&gt; = cell.try_borrow_mut()?;
let _: &amp;mut MyClass = &amp;mut *py_ref_mut;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p><code>PyCell&lt;T&gt;</code> can also be accessed like a Python-native type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass { })?;

// Use methods from PyAny on PyCell&lt;T&gt; with Deref implementation
let _ = cell.repr()?;

// To &amp;PyAny automatically with Deref implementation
let _: &amp;PyAny = cell;

// To &amp;PyAny explicitly with .as_ref()
let _: &amp;PyAny = cell.as_ref();
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#pyrefsometype-and-pyrefmutsometype" id="pyrefsometype-and-pyrefmutsometype"><code>PyRef&lt;SomeType&gt;</code> and <code>PyRefMut&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> reference wrapper types employed by <code>PyCell</code> to keep track of
borrows, analog to <code>Ref</code> and <code>RefMut</code> used by <code>RefCell</code>.</p>
<p><strong>Used:</strong> while borrowing a <code>PyCell</code>.  They can also be used with <code>.extract()</code>
on types like <code>Py&lt;T&gt;</code> and <code>PyAny</code> to get a reference quickly.</p>
<h2><a class="header" href="#related-traits-and-types" id="related-traits-and-types">Related traits and types</a></h2>
<h3><a class="header" href="#pyclass" id="pyclass"><code>PyClass</code></a></h3>
<p>This trait marks structs defined in Rust that are also usable as Python classes,
usually defined using the <code>#[pyclass]</code> macro.</p>
<h3><a class="header" href="#pynativetype" id="pynativetype"><code>PyNativeType</code></a></h3>
<p>This trait marks structs that mirror native Python types, such as <code>PyList</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="python_from_rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="parallelism.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="python_from_rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="parallelism.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
